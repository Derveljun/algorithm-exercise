- 이 문서는 Typora 마크다운 편집기로 만들어졌습니다.
- Typora 문법 제거는 추후에 할 예정

#  알고리즘의 기본

[TOC]

## 알고리즘이란?

계산이나 작업을 하기 위한 순서를 의미한다.



## 계산 시간을 측정하는 방법

스탭 수





# 데이터구조

## 데이터 구조란?

### 데이터의 순서나 위치 관계를 정하는 것.

컴퓨터 메모리의 저장되는 형태를 의미한다. 

데이터를 메모리에 저장할 때 데이터의 순서나 위치 관계 등을 정하는 것.



### 데이터 구조를 고민하여 메모리 이용 효율을 높인다.





## 리스트 List

> 리스트는 데이터를 일직선으로 나열한 형태를 가지고 있다. 데이터의 추가나 삭제는 쉽지만, 찾고자하는 데이터 접근에는 시간이 많이 걸린다.

{1, P2} -> {3, P3} -> {2, P4} -> {5, P_none}

- 시간
  - 조회: O(n) ; 선형 탐색
  - 추가 삭제: O(1); 포인터 변경

`포인터`란 리스트내 데이터가 가지는 메모리 위치를 가르키는 부분을 의미한다.

조회시 계산시간은 데이터 수를 `n`이라 했을 때, 선형탐색에 따라 찾기 때문에 `O(n)`만큼 걸린다.

데이터의 변형(추가, 삭제)은 데이터의 포인터 변경만 하면 되기 때문에 `O(n)`만큼 걸린다.

- 원형 리스트

  마지막 데이터의 포인터가 처음을 가르키고 있는 형태

  {1, P2} -> {3, P3} -> {2, P4} -> {5, P1}

- 양방향 리스트

  데이터의 포인터가 앞 뒤로 존재하며, 앞과 뒤의 포인터가 서로를 마주보고 있는 형태이다. 이때에는 데이터 변형에 있어 수정해야할 포인터 수가 늘어나기 때문에 저장 영역이 증가하는 점과 수정에 필요한 시간이 증가한다는 단점이 있다.

  {P_none, 1, P2} <--> {P2, 3, P3} <--> {P3, 2, P4} <--> {P4, 5, P_none}



## 배열 Array

> 데이터를 1열로 나열한 형태. 리스트와는 반대로 데이터 접근은 쉽지만, 추가와 삭제에 시간이 오래걸린다.

{1, 2, 5, 3, 4, 9 , 8}

- 시간
  - 조회: O(1); 랜덤 액세스
  - 추가, 삭제: O(n); 배열재조정

배열은 연속된 메모리 영역에 순서대로 저장되어 있다. 연속된 영역에 저장돼 있어 첨자를 사용해 메모리 주소를 계산할 수 있다. 즉, 이러한 점 덕분에 데이터에 바로 접근이 가능하다. 이것을 임의 점근(random access, 랜덤 액세스)라 한다.

조회 시에는, 인덱스의 주소만 가지고 바로 접근이 가능하다.

추가, 삭제는 공간을 재할당해야하므로 리스트에 비해 훨씬 많은 시간이 필요하다.

추가시에는 마지막에 공간을 추가하고 필요한 부분을 비우기위해 순차적으로 데이터를 밀어낸다. 삭제시에는 삭제가 필요한 부분에 공간을 비우고 데이터를 순차적으로 당긴 뒤, 마지막 공간을 삭제한다.





## 스택 Stack

> 데이터를 쌓아가는 형태. 책을 바닥에서 쌓는 형태.

- Push / Pop
- Last In - First Out; LIFO; 후입선출

항상 최신 데이터를 참조해야하는 경우 유리하다.





## 큐 Queue

> 데이터를 1열로 나열한 구조. 대기 행렬

- Enqueue / Dequeue
- First In - First Out; FIFO; 선입선출

대기행렬,  너비우선탐색에서 후보 관리에 큐를 활용.





## 해시 테이블 Hash Table, Hash Map

- Key / Value
- 해시 함수를 통해 구한 해시값을 배열에 저장한다.
- 색인(index) / Bucket / Slot / Mod
- 충돌 시에는 체이닝으로 처리하는 방법이 대표적이다.



### 유투브 동영상의 원본을 어떻게 알까?

유투브는 누군가 내 영상을 자기 유투브에 같은 영상을 올리려할 때 원본 영상을 가진이에게 알려준다. 그 많은 유투브 영상을 대상으로 원본 영상을 가진이가 누구인지 같은 영상인지를 어떻게 비교할까? 바로 해시 테이블을 통해 그 문제를 해결할 수 있다.



### 블록체인은 그 많은 장부거래를 어떻게 비교할까?

블록체인은 블록체인 네트워크에 참여하는 모든 참여자가 같은 거래 장부를 가진다는 특성이 있다. 그렇다면, 블록체인의 그 많은 거래건은 어떻게 검증하고 가지고 있을 수 있을까? 바로 이런 특성에 이용되는 것이 해시코드이다. 

블록체인은 10분 간격으로 10분내에 일어난 모든 거래를 블록체인 창고에 저장한다. 서비스 시작이래 모든 사용자들의 모든 거래장부를 전자지갑에서 가지고 있는데, 이 거래내역을 검증하려면 지갑비교에 오래걸릴 수 있으니, 이 거래장부를 해시코드로 만들어 비교한다. 

공백하나 점하나만으로도 해시코드가 다르므로 충분히 검증될 수 있는 것이다.



### 해시테이블의 특징

해시테이블은 검색속도가 정말 빠르다. 그 이유는 해시 키 값을 가지고 만든 해시코드는 정수인데, 이 정수를 인덱스에 바로 사용하기 때문이다.  배열 공간을 고정길이만큼 만들어 해시코드만 알면 바로 인덱스를 알 수 있기 때문에 빠른 것이다.



### 해시 알고리즘

해시값을 모드 값(어떤 숫자로 나누어 나온 나머지 값)을 인덱스로 하여 해시테이블에 저장한다. 

간단한 해시 알고리즘을 만들어보자.

````java
int getHashCode(char[] args){
    int sum = 0;
    for (int i=0; i < args.length; i++){
        sum += (int) args[i];
    }
    return sum;
}
````

가장 간단하게 문자열의 ASCII 값을 Sum하여 해시코드를 만들었다.

이제, 해시테이블에 저장할 배열방 지정하는 코드를 만들어보자.

````java
int convert2Index(int hashCode){
    return hashCode % hashTable.length;
}
````





### 해시테이블의 문제점, 해시충돌(Hash Collision)

해시알고리즘은 

- 해시 키의 값 자체는 다르지만, 같은 해시코드는 만들 수 있다.
- 다른 해시 코드를 가졌지만, 인덱스를 배정할 때 배열방이 한정되어 같은 인덱스 방을 배정할 수 수도 있다.

바로 이러한 경우를 해시충돌(Collision)이라 한다. 

위와 같이 다른 키값의 해시코드가 같거나, 인덱스가 같은 경우가 발생하는 경우를 최소화하고 골고루 잘 분배해 저장할 수 있는 알고리즘을 좋은 해시테이블 알고리즘이라 할 수 있다. 



### 해시충돌의 해결, 연쇄법(Chaning)

같은 모드 값으로 나온 경우 - 충돌이 일어난 경우 해당 인덱스 내에서는 Linked List 구조로 인덱스 내에 값을 엮어준다. 이러한 방법을 바로 연쇄법(Chaining)이라 한다. 

해시 테이블의 배열 크기가 너무 작을 때에는 충돌이 많아 선형 탐색의 빈도가 높아지게 되고, 너무 클 때에는 메모리 낭비가 심해지므로 배열 크기를 적절히 관리하여야 한다.

충돌처리는 체이닝 외에도 '개방주소법(Open Addressing)' 이 있다. 개방주소법은 충돌 시 배열상에 후보 주소를 찾아 저장하는 방법이다. 이 때에는 빈 배열 주소를 찾아 충돌 위치에 주소를 매핑하는 과정에서 선형탐색을 사용하게 된다.

유연한 저장과 빠른 접근이 가능한 장점으로 연관 배열(associative array)등에 사용하고 있다.



### 해시테이블과 해시알고리즘 구현하기

````java
class HashTable {
    
    class HashNode {
        private String key;
        private String value;
        
        public HashNode(String key, String value){
            this.key = key;
            this.value = value;
        }

        // Get, Setter
        public void key(String key){
            this.key = key;
        }
        public String key(){
            return this.key;
        }
        public String value(){
            return value;
        }
        public void value(String value){
            this.value = value;
        }
    }
    
    LinkedList<HashNode>[] dataList;
    public HashTable(int hashSize){
        this.dataList = new LinkedList<HashNode>[hashSize];
    }
    
    public int getHsahCode(String key){
        char[] arrChr = key.getCharArrays();
        
        int sum=0;
        for(int i=0; i<arrChr.length; i++){
            sum += (int) arrChr[i];
        }
        return sum;
    }
    
    public int conver2Index(int hashCode){
        return hashCode % dataList.length;
    }
    
    HashNode searchKey(LinkedList<HashNode> list, String key){
        if (list == null) 
            return null;
        
        for (HashNode curNode : dataList) {
            if (curNode.key.equal(key)) 
                return curNode;
        }
        
        return null;
    }
    
    public void put(String key, String value){
        int hashCode = getHashCode(key);
        int idx = convert2Index(hashCode);
        LinkedList<HashCode> nodeList = dataList[idx];
        if(nodeList == null){
        	nodeList = new LinkedList<HashNode>();
            dataList[idx] = valueList;
        }
        
        HashNode searchedNode = searchKey(nodeList, key);
        if ( searchedNode == null )
            nodeList.addLast(new HashNode(key, value));
        else 
            searchedNode.value(value);
    }
    public String get(String key){
        int hashcode = getHashCode(key);
        int idx = convert2Idx(hashcode);
        LinkedList<HashNode> nodeList = dataList[idx];
        HashNode searchedNode = searchKey(nodeList, key);
        return (searchedNode == null) 
            ? "Not Found" : searchedNode.value();
    }
    
    public static void main(String[] args){
        HashTable ht = new HashTable(3);
        ht.put("sung", "pretty");
        ht.put("jae", "cute");
        ht.put("hee", "like a model");
        ht.put("hee", "beautiful");
        
        System.out.println(ht.get("sung"));
        System.out.println(ht.get("jae"));
        System.out.println(ht.get("hee"));
    }
}
````





## 힙 Heap

> 힙은 그래프 트리 구조 중 하나이다. 
> 우선순위 큐(Priority Queue)를 구현 시 사용된다.



우선순위 큐는 데이터를 자유롭게 추가할 수 있다. 추출 시에는 최소값부터 순서대로 선택한다. 추가는 자유롭고, 추출할 때에는 작은 값부터 꺼내는 것이 우선순위 큐이다.

트리 구조에서 각 정점을 노드라 한다. 노드에 데이터가 저장된다.

힙에서는 노드의 숫자가 부모보다 반드시 커야한다. 따라서 루트는 가장 작은 값을 가지고 있다. 노드를 추가할 때에는 이 규칙을 지키기 위해 가장 아래에 있는 층에 있는 왼쪽 노드부터 채워나간다. 가장 아래 층이 모두 재워지면, 새로운 층을 만들어 가장 왼쪽에 채운다.

- 추가

1. 추가 시에 가장 아래층 노드에 저장한다.
2. 부모의 숫자가 자식 보다 큰 경우 서로 교환한다. 
3. 반복: 2의 과정을 자식과 부모를 비교하며 반복한다.

- 추출

1. 최솟값부터 추출하기 때문에 항상 가장 위에 있는 숫자를 추출한다. 
2. Root를 채우기 위해 가장 아랫층의 오른쪽에 위치한 숫자를 루트로 올린다.
3. 반복: 부모와 자식을 비교하며 더 작은 쪽과 교환해간다.

힙은 항상 가장 최솟값이 루트에 있어, 데이터 수와 상관없이 O(1) 시간에 추출할 수 있다. 추출 후 데이터를 재정렬할 시에는 가장 후미 데이터를 가장 위로 가져와 자식과 비교해가며 아래방향으로 데이터를 정렬한다. 이 때문에 계산 시간은 트리의 높이와 비례하게 된다. 따라서 데이터 수를 n이라 했을 대 힙 형성 조건에 따라 트리의 높이는 $$log_2n$$ 이므로 재구축 시간은 O(log n)이 된다.

최소값을 자주 추출할 때에 유리하다.



## 이진 탐색 트리

> 그래프의 트리 구조 각 노드는 최대 두개의 자식 노드를 가진다.

중요 성질은 두 가지이다.

첫 번째 성질은 모든 노드는 왼쪽 가지에 포함되는 어떤 숫자보다도 큰 숫자가 된다는 것.

두 번째 성질은 모든 노드는 그 노의 오른쪽 가지에 포함되는 어던 숫자보다 작은 숫자가 된다는 것.



즉, 노드의 부모의 왼쪽은 부모보다 작은 수, 부모의 오른쪽은 부모보다 큰 수를 가지고 있다.



- 추가
  1. 추가되는 값의 대소를 찾으며, 아래 방향으로 찾아간다. 
  2. 첫 노드와 비교해 크면 오른쪽 작으면 왼쪽
  3. 반복: 다음 노드와 비교해 크면 오른쪽 작으면 왼쪽
- 삭제
  1. 삭제할 노드를 비운다.
  2. 삭제한 노드의 왼쪽 또는 오른쪽 노드에서 가장 최대 값 노드를 찾는다.
  3. 최대값 노드를 삭제한 노드로 이동시킨다. 
- 탐색
  1. 루트에서 값을 비교한다. 작으면 왼쪽 크면 오른쪽
  2. 반복: 다음 노드에서 값을 비교한다. 작으면 왼쪽 크면 오른쪽 노드로 이동한다.



이진 탐색의 개념을 트리 구조로 표현한 것. 데이터 탐색 / 추가에 있어 최적의 위치를 찾을 때, 두 가지 성질을 기준으로 대소만을 비교해 왼쪽이냐 오른쪽이냐를 정하면 된다.

트리의 높이(깊이)만큼만 비교를 하면되므로, 노드가 n개 있고 트리가 균형 잡힌 경우에는 최대 $$log_2n$$ 회의 비교로 이동한다. 따라서 계산 시간은 O(log n)이 된다.  하지만, 트리가 한쪽으로 치우쳐서 직선과 같다면, 트리 높이가 높아져 O(n)이 될 수도 있다.

이진 탐색 트리를 확장한 데이터 구조는 자가형 이진 탐색 트리(self-balancing binary search tree)라고 하며, 탐색 효율을 유지할 수 있다. 

이진 트리의 노드를 최대 2개를 가지는 대신에 자식 수 제한없이 가져 트리 균형을 도모한 B트리도 있다.



# 정렬

## 정렬이란?

> 주어진 수를 순서대로 나열하는 것.



### 최선, 최악, 평균의 경우

|  알고리즘   | 자료 구조 | 시간복잡도    | 시간복잡도    | 시간복잡도    | 공간복잡도 |
| :---------: | :-------: | ------------- | ------------- | ------------- | ---------- |
|             |           | 최선          | 평균          | 최악          | 최악       |
|  버블 정렬  |   배열    | $O(n)$        | $O(n2)$       | $O(n2)$       | $O(1)$     |
|  선택 정렬  |   배열    | $O(n2)$       | $O(n2)$       | $O(n2)$       | $O(1)$     |
|  삽입 정렬  |   배열    | $O(n)$        | $O(n2)$       | $O(n2)$       | $O(1)$     |
|   퀵 정렬   |   배열    | $O(n log(n))$ | $O(n log(n))$ | $O(n2)$       | $O(1)$     |
|  합병 정렬  |   배열    | $O(n log(n))$ | $O(n log(n))$ | $O(n log(n))$ | $O(n)$     |
|   힙 정렬   |   배열    | $O(n log(n))$ | $O(n log(n))$ | $O(n log(n))$ | $O(1)$     |
| 스무스 정렬 |   배열    | $O(n)$        | $O(n log(n))$ | $O(n log(n))$ | $O(1)$     |

#### 복잡도의 종류

- 시간 복잡도(Time Complexity) : 알고리즘 연산횟수의 총합
- 공간 복잡도(Space Complexity) : 알고리즘 사용메모리의 총량



### 참고

- [최선, 최악, 그리고 평균의 경우](<https://ko.wikipedia.org/wiki/%EC%B5%9C%EC%84%A0,_%EC%B5%9C%EC%95%85,_%EA%B7%B8%EB%A6%AC%EA%B3%A0_%ED%8F%89%EA%B7%A0%EC%9D%98_%EA%B2%BD%EC%9A%B0>)



## 교환: 버블정렬 Bubble Sort

>  오른쪽부터 왼쪽 방향으로 인접한 두 개의 숫자를 비교해서 교환하는 정렬방법.
>  오른쪽에서 왼쪽으로 숫자가 옮겨가는 모양이 물속에서 거품이 올라오는 모양과 비슷하다하여 버블이라 한다.



### 알고리즘을 풀어보며 이해하기

정렬할 데이터는 아래와 같다.
[8, 3, 5, 9, 4]

[(8, 3), 5, 9, 4]
[(3, 8), 5, 9, 4]
[3, (8, 5), 9, 4]
[3, (5, 8), 9, 4]
[3, 5, (8, 9), 4]
[3, 5, 8, (9, 4)]
[3, 5, 8, (4, 9)]

[(3, 5), 8, 4, 9]
[3, (5, 8), 4, 9]
[3, 5, (8, 4), 9]
[3, 5, (4, 8), 9]

[(3, 5), 4, 8, 9]
[3, (5, 4), 8, 9]
[3, (4, 5), 8, 9]

[3, 4, 5, 8, 9]



### 알고리즘 정리하기

1. 가장 오른쪽 수를 기준으로 바로 옆 숫자를 비교한다.
2. 비교한 숫자가 더 작으면 서로 값을 치환한다.
3. 더 크면 다음으로 넘어간다.



```java
void bubbleSort(int... arr){
    
    int swap;
    for(int i=0; i < arr.length; i++){
        for(int j=1; j < arr.length-i; j++){
            if(arr[j-1] > arr[j]){ // 부등호가 < 가 되면 역정렬이 가능하다.
                swap = arr[j];
                arr[j] = arr[j-1];
                arr[j-1] = swap;
            }
        }
    }
}
```

```java
void bubbleSort_isSorted(int... arr){
    boolean isSorted = true;
    for(int i=0; i < arr.length; i++){
        for(int j=1; i < arr.length - i; j++){
            if(arr[j-1] > arr[j]){ 
                isSorted = false;
                break;
            }
        }
        
        if(!isSorted){
            return false;
        }
    }
}
```



버블 소트는 1라운드에서 n-1회를 하며, 이 비교 횟수는 $$n^2/2$$ 가 된다.

계산 시간은 $$O(n^2)$$이 된다. 



### 장단점과 특징

속도가 느리지만, 코드는 간단하다.
최적화 또한 뚜렷한 성능 향상을 기대하기 어렵다.

모든 정렬 중에서 가장 비효율적인 알고리즘이다.
배열 요소를 계속 비교하여 최대값을 배열 끝으로 밀어내는 모습이
거품과 같다하여 거품 정렬이라 한다.

데이터 수가 작아 속도에 영향을 미치지 않는 경우, 또는 이미 정렬되었는지 탐지할 수 있다는 점이 그나마 사용할만한 예제이다.



### 참고

- <https://makefortune2.tistory.com/30?category=645583>





## 선택: 선택 정렬 Selection Sort

> 수열 중에서 최솟값을 선형 탐색한 후, 왼쪽 끝에 있는 숫자와 교체하는 방법.

![](E:\OneDrive\01. 개인\프로그래밍\Algorithm\Algorithm.asset\Selection-Sort-Animation.gif)

### 알고리즘을 풀어보며 이해하기

정렬하고자 하는 데이터는 아래와 같다.

[7, 4, 6, 5, 8, 9, 3, 1]

정렬대상 인덱스 `index 0`에서부터 배열 끝가지 최솟값을 찾는다.
[(7), 4, 6, 5, 8, 9, 3, 1]
[(7), 4, 6, 5, 8, 9, 3, <1>]
[(1), 4, 6, 5, 8, 9, 3, 7]
최솟값 최초는 정렬대상 인덱스 값 `7`을 다음 비교대상 인덱스 `index 1`에 값 `4`와 비교하여 비교대상 값이 더 작으면 최솟값에 값을 바꾼다. 

[1, (4), 6, 5, 8, 9, 3, 7]
[1, (4), 6, 5, 8, 9, <3>, 7]
[1, (3), 6, 5, 8, 9, 4, 7]

[1, 3, (6), 5, 8, 9, 4, 7]
[1, 3, (6), 5, 8, 9, <4>, 7]
[1, 3, (4), 5, 8, 9, 6, 7]

[1, 3, 4, (5), 8, 9, 6, 7]
[1, 3, 4, <(5)>, 8, 9, 6, 7]
[1, 3, 4, (5), 8, 9, 6, 7]

[1, 3, 4, 5, (8), 9, 6, 7]
[1, 3, 4, 5, (8), 9, <6>, 7]
[1, 3, 4, 5, (6), 9, 8, 7]

[1, 3, 4, 5, 6, (9), 8, 7]
[1, 3, 4, 5, 6, (9), 8, <7>]
[1, 3, 4, 5, 6, (7), 8, 9]

[1, 3, 4, 5, 6, 7, (8), 9]
[1, 3, 4, 5, 6, 7, <(8)>, 9]
[1, 3, 4, 5, 6, 7, (8), 9]

[1, 3, 4, 5, 6, 7, 8, (9)]
[1, 3, 4, 5, 6, 7, 8, <(9)>]
[1, 3, 4, 5, 6, 7, 8, (9)]



### 알고리즘 정리하기

1. 선형 탐색으로 최솟값을 찾는다.
2. 제일 왼쪽 숫자와 치환한다.

```java
int[] selectionSort (int... arr){
    int swap, minIdx;
    
    for(int i=0; i<arr.length; i++){
        minIdx = i;
        for(int j=i+1; j<arr.length; j++){
            minIdx = (arr[minIdx] > arr[j]) ? j : minIdx;
        }
        
        swap = arr[i];
        arr[i] = arr[minIdx];
        arr[minIdx] = swap;
    }
}
```





### 장단점과 특징

1라운드에서 n-1회를 하며, 이 비교 횟수는 $$n^2/2$$ 가 된다.
계산 시간은 $$O(n^2)$$이 된다. 

알고리즘이 단순하기 때문에 메모리가 제한적인 상황에서 성능 상의 이점이 있다.

거품정렬(Bubble Sort)보다 항상 우수한 성능을 보여준다.

삽입정렬(Insertion Sort)과는 달리 모든 배열값을 봐야 한다는 점에서 효율성이 조금 떨어진다.

합병정렬(Merge Sort)과 대비하여 합병 정렬과 같은 분할 정복 알고리즘을 사용하지만, 작은 배열에서(20개 이내) 더 속도가 빠르다. 





### 참고

- <https://makefortune2.tistory.com/31?category=645583>
- 



## 삽입: 삽입 정렬 Insertion Sort

### 삽입정렬 알고리즘

삽입정렬이란 배열의 모든 요소를 앞에서부터 차례대로 정렬된 배열과 비교하여 배열의 위치를 찾아 삽입 정렬하는 과정을 반복하여 정렬하여 완성하는 알고리즘을 의미한다.

점진적으로 정렬의 대상 범위가 넓어진다.

![](\Algorithm\Algorithm.asset\Insertion_sort.gif)



### 알고리즘을 풀이해보며 이해하기

정렬하고자 하는 데이터는 다음과 같다.

[5, 8, 4, 2, 9, 6, 3, 2, 1, 7]



정렬대상 인덱스를 선택한다.
첫 정렬대상 인덱스는 `index 0`이 아닌 `index 1`부터 시작한다.

[5, (8), 4, 2, 9, 6, 3, 2, 1, 7] 

정렬대상 인덱스 값인 `8`을 비교대상 인덱스 값인 `5`보다 작은가? (8 < 5)?
아니므로, 정렬대상 인덱스`index 1`를 다음 인덱스인 `index 2`로 넘긴다.



정렬대상 인덱스`index 2`보다 작은 인덱스 배열`index 0 ~ 1`이  비교대상 인덱스가 될 것이다.

[5, 8, (4), 2, 9, 6, 3, 2, 1, 7]

[5, (4), 8, 2, 9, 6, 3, 2, 1, 7]

[(4), 5, 8, 2, 9, 6, 3, 2, 1, 7]

정렬대상 인덱스`index 2`의 값 `4`가 비교대상 인덱스 `index 1`값 `8` 보다 작은가? (4 < 8)?
맞다면 서로의 값을 스왑(Swap)한다. 즉, 정렬대상 인덱스`index 2`의 값을 비교대상 인덱스`index 1`과 맞바꾼다. 

이제, 정렬대상 인덱스는 `index 2`에서 `index 1` 로 바뀌었고, 비교대상 인덱스는 `index 0`으로 한다. 
다시 정렬대상 인덱스 `index 1` 값 `4`이 비교대상 인덱스 `index 0`의 값 `5`보다 작은가?(4<5)?
작으므로 다시 스왑한다.
이번에는 비교대상 인덱스가 더 이상 없으므로 첫 시작점이었던 정렬대상 인덱스`index 2`보다 1만큼 큰 정렬대상 인덱스`index 3`으로 정렬대상 인덱스로 넘긴다.



[4, 5, 8, (2), 9, 6, 3, 2, 1, 7]

[4, 5, (2), 8, 9, 6, 3, 2, 1, 7]

[4, (2), 5, 8, 9, 6, 3, 2, 1, 7]

[(2), 4, 5, 8, 9, 6, 3, 2, 1, 7]



[2, 4, 5, 8, (9), 6, 3, 2, 1, 7]



[2, 4, 5, 8, 9, (6), 3, 2, 1, 7]

[2, 4, 5, 8, (6), 9, 3, 2, 1, 7]

[2, 4, 5, (6), 8, 9, 3, 2, 1, 7]





[2, 4, 5, 6, 8, 9, (3), 2, 1, 7]

[2, 4, 5, 6, 8, (3), 9, 2, 1, 7]

[2, 4, 5, 6, (3), 8, 9, 2, 1, 7]

[2, 4, 5, (3), 6, 8, 9, 2, 1, 7]

[2, 4, (3), 5, 6, 8, 9, 2, 1, 7]

[2, (3), 4, 5, 6, 8, 9, 2, 1, 7]



[2, 3, 4, 5, 6, 8, 9, (2), 1, 7]

[2, 3, 4, 5, 6, 8, (2), 9, 1, 7]

[2, 3, 4, 5, 6, (2), 8, 9, 1, 7]

[2, 3, 4, 5, (2), 6, 8, 9, 1, 7]

[2, 3, 4, (2), 5, 6, 8, 9, 1, 7]

[2, 3, (2), 4, 5, 6, 8, 9, 1, 7]

[2, (2), 3, 4, 5, 6, 8, 9, 1, 7]



[2, 2, 3, 4, 5, 6, 8, 9, (1), 7]

[2, 2, 3, 4, 5, 6, 8, (1), 9, 7]

[2, 2, 3, 4, 5, 6, (1), 8, 9, 7]

[2, 2, 3, 4, 5, (1), 6, 8, 9, 7]

[2, 2, 3, 4, (1), 5, 6, 8, 9, 7]

[2, 2, 3, (1), 4, 5, 6, 8, 9, 7]

[2, 2, (1), 3, 4, 5, 6, 8, 9, 7]

[2, (1), 2, 3, 4, 5, 6, 8, 9, 7]

[(1), 2, 2, 3, 4, 5, 6, 8, 9, 7]



[1, 2, 2, 3, 4, 5, 6, 8, 9, (7)]

[1, 2, 2, 3, 4, 5, 6, 8, (7), 9]

[1, 2, 2, 3, 4, 5, 6, (7), 8, 9]



### 알고리즘 정리하기

- 정렬할 배열데이터의 첫 인덱스 다음 인덱스인 1부터 시작하여 한다. 
  ```for(int i=1; i < 배열길이 - 1; i++)```

- 정렬대상 인덱스 값이 정렬대상 인덱스보다 1만큼 작은 비교대상 인덱스가 0일 때까지 비교한다.
  ``` for(int j=i; j>0; j= j-1)```

  

- 정렬대상 인덱스 값이 비교대상 인덱스 값 보다 작다면 
  `if( arr[j] < arr[j-1] )`
  값을 서로 스왑한다.
  `swap_temp = arr[j-1]
  arr[j-1] = arr[j]
  arr[j] = swap_temp`

- 작지 않다면, 비교 loop 문을 끝낸다.
  `else break`

```java
/**
 * 정렬대상 값과 비교대상 값을 비교하여 작으면 계속해서 값을 스왑하여 
 * 값을 왼쪽으로 이동
 */
int[] insertSort (int... arrData) {
	
	System.out.println(Arrays.toString(arrData));
	
	int swapTemp;
	for( int i=1; i < arrData.length; i++) {
		
		for( int j=i; j > 0; j--) {
			// 부등호가 > 가 되면 역정렬이 가능하다.
			if ( arrData[j] < arrData[j-1]) {
				swapTemp = arrData[j-1];
				arrData[j-1] = arrData[j];
				arrData[j] = swapTemp;
			} else {
				break;
			}
			
		}
		
	}
	
	System.out.println(Arrays.toString(arrData));
	return arrData;
}
```



``` java
/**
 * 정렬대상 값을 왼쪽으로 계속 swap 하는 것이 아니라,
 * 정렬대상 값을 tmp값에 담아두고 보다 작은 비교대상 값을 계속해서 오른쪽으로 밀어내는 방식
 **/
int[] insertSort2 (int... arrData) {
	
	System.out.println(Arrays.toString(arrData));
	
	int swapTmp, idxAux;
	for ( int i=1; i < arrData.length; i++ ) {
		
		swapTmp = arrData[i];
		idxAux = i-1;
		
		while ( (idxAux >= 0) && ( swapTmp < arrData[idxAux] ) ) {
			arrData[idxAux + 1] = arrData[idxAux];
			idxAux--;
		}
		arrData[idxAux + 1] = swapTmp;
		
	}
	
	System.out.println(Arrays.toString(arrData));
	
	return arrData;
}
```





### 장단점과 특징

배열이 길어질 수록 효율이 떨어진다. 

구현이 간단하다.

선택 정렬이나 거품 정렬과 같은 $O(n^2)$ ; 차수알고리즘에 비하면 빠른 편이다. 

안정 정렬이면서, in-place 알고리즘이다.

반복 정렬의 과정에서 스왑이 중요하게 쓰인다.

정렬이 되지 않은 상태에서는 빠르지 않다. 



### 알고리즘 성능

최악에서는 역순으로 된 경우.

왼쪽에서부터 cursor를 이동하며 값을 정렬된 수에서 다시한번 비교하기 때문에 두 번 조회하게 된다. 

정렬 시간은 버블 / 선택 정렬과 같은 $$O(n^2)$$이다.



### 삽입 정렬의 실제 활용

// TODO java 에서의 Collections 와 Arrays 이해하기.





### 관련 링크

- [국문 삽입정렬 위키피디아](https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC)
- [영문 삽입정렬 위키피디아](<https://en.wikipedia.org/wiki/Insertion_sort>)
- [블로그1](<https://ehclub.co.kr/1840>)
- [자바 Comparable and Comparator](<https://gmlwjd9405.github.io/2018/09/06/java-comparable-and-comparator.html>)







## 분할: 퀵 정렬 Quick Sort

> 임의 기준 수, 피봇(Pivot)을 정하여 피봇과 다른 수를 비교해가며 작은 수는 왼쪽으로, 큰 수는 오른쪽으로 그룹화한다. 그룹화 된 수열에서 다시 피봇을 구하여 그룹화한다.

특정 수를 기준(Pivot)으로 큰 숫자와 작은 숫자로 나누자(분할하자)!



![](Algorithm\Algorithm.asset\Sorting_quicksort_anim.gif)



### 알고리즘을 풀이해보며 이해하기

[4, 6, 3, 5, 8, 9, 2, 1, 7, 10]
[`4`, 6, 3, 5, 8, 9, 2, 1, 7, 10] - P 는 대개 첫번째 인덱스를 선정한다.
[`4`, **6**, 3, 5, 8, 9, 2, **1**, 7, 10] - P 를 제외한 제일 작은 인덱스는 `i` 라 하고 `p`보다 큰 값을 찾는다.
여기서는 `i` 인덱스의 값이 `p` 인덱스 값보다 크므로 `6` 선택되었다. 
`j`는 `p`보다 작은 값을 찾는다. 여기서는 `10`이나 `7` 보다 `1`이 더 작으므로 `i`인덱스 값은 `1`로 한다.

[`4`, **1**, 3, 5, 8, 9, 2, **6**, 7, 10] - `1`과 `6`의 서로 인덱스 값을 바꿔준다.
[`4`, 1, 3, **5**, 8, 9, **2**, 6, 7, 10] - `i`와 `j`를 재선택한다.
[`4`, 1, 3, **2**, 8, 9, **5**, 6, 7, 10] - 서로의 값을 바꿔준다.

[`4`, 1, 3, 2, 8, 9, 5, 6, 7, 10] - 이제 더 이상 바꿔줄 것이 없으니 마지막 `i`의 값, 즉 `p`보다 작은 인덱스와 위치를 교환한다. 
[2, 1, 3, `4`, 8, 9, 5, 6, 7, 10] - `p` 보다 작은 값은 왼쪽에 위치했고, 큰 값은 오른쪽에 위치했다.

이제부터는 **`분할`** 된 각 배열을 재귀적으로 퀵정렬을 해준다.

[`2`, 1, 3] - 여기서는 `i` 와 `j`를 양끝에서 수행했지만, 바꿔줄 내용이 없다. `i`와 `p`를 바꿔준다.
[1, `2`, 3] - 더 이상 분할하여 퀵정렬할 값이 없으므로 정렬을 끝낸다.

[`8`, 9, 5, 6, 7, 10] - `p`을 기준으로 `i`와 `j`를 찾는다. 
[`8`, **9**, 5, 6, **7**, 10] 
[`8`, **7**, 5, 6, **9**, 10]
[`8`, 7, 5, 6, 9, 10] - `i`와 `j`를 계속 각각 증가 / 감가 하면서 `i`가 `j`와 같거나 커졌다면 `i`의 위치와 `p`의 위치의 값을 바꿔준다.
[6, 7, 5, `8`, 9, 10] 
[`6`, 7, 5] 
[`6`, 5, 7]
[5, `6`, 7]

자, 이제 정렬이 완료되었다.





### 알고리즘 정리하기

```java
void quickSort(int[] data, int l, int r){

    int left = l, right = r, pivot = data[(l+r) / 2], swap;
    
    while( left <= right ) {
        while(data[left] < pivot) left++;
        while(data[right] > pivot) right--;
        
        if(left <= right){
            swap = data[left];
            data[left] = data[right];
            data[right] = swap;
            
            left++;
            right--;
        }
    }
    
    if(l < right) quickSort(data, l, right);
    if(r > left) quickSort(data, left, r);
    
}

public static void main(String... args){
    int[] data = new int[]{ 4, 7, 3, 5, 1, 9, 8, 2, 10};
    
    quickSort(data, 0, data.length);
}
```





### 장단점과 특징

$O(n)$를 한번 생각해보자, 버블/삽입/선택 정렬은 $O(n^2)$,
[1 ~ 10]까지의 10개의 `length`를 가지는 배열을 정렬한다면,

즉, $O(n^2) = 10 * 10 = 100$ 이란 시간복잡도가 나온다.
반면에, 분할을 통해 계산을 한다면
$O(nlog(n)) = 10/2 * 10 = 50$ 이란 시간복잡도가 나오게 되는데 이는 연산 속도에서 큰 차이를 내게 된다.

다만, 편향 되게 분할할 수 있기 때문에 최악에서는 $O(n^2)$ 이 될 수 있다는 단점이 있다.



## 분할: 병합정렬(합병정렬, Merge Sort)

|먼저 반으로 잘게 자르고, 합친다



### 알고리즘을 풀이해보며 이해하기

#### 나누기

[4, 8 ,2, 9 ,3, 5, 1, 7, 6, 10]
[4, 8 ,2, 9 ,3] [5, 1, 7, 6, 10]
[4, 8] [2, 9 ,3] [5, 1] [7, 6, 10]
[4] [8] [2] [9 ,3] [5] [1] [7] [6, 10]
[4] [8] [2] [9] [3] [5] [1] [7] [6] [10]



#### 정렬하며 합치기

[4] [8] [2] [9] [3] [5] [1] [7] [6] [10]
[4, 8] [2, 9] [3] [5] [1] [7] [6] [10]
[2, 4, 8, 9] [3] [5] [1] [7] [6] [10]
[2, 3, 4, 8, 9] [5] [1] [7] [6] [10]
[2, 3, 4, 8, 9] [1, 5] [6, 7] [10]
[2, 3, 4, 8, 9] [1, 5, 6, 7] [10]
[2, 3, 4, 8, 9] [1, 5, 6, 7, 10]
[1, 2, 4, ,5, 6, 7, 8, 9, 10]



### 알고리즘 정리하기

```java
static int[] sorted;

static void merge(int[] arr, int left, int mid, int right){
    int i, j, k, l;
    i = left; j = mid+1; k = right;
    
    // 병합 정렬
    while(i <= mid && j <= right){
        sorted[k++] = (arr[i] <= arr[j])
                    ? arr[i++] : arr[j++];
    }
    
    // 남은 값을 병합 정렬
    l = ( mid < i ) ? j : i;
    for(l=j; l <= right; l++)
        sorted[k++] = arr[l];
    
    // 원 배열에 임시 배열 덮어쓰기
    for(l=left; l <= right; l++)
        arr[l] = sorted[l];
}

static void mergeSort(int[] arr, int left, int right){
    if ( left < right) {
        int mid = (left + right) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        
        merge(arr, left, mid, right);
    }
}

public static void main(String[] args){ 
    int i;
    int[] arr = {24, 10, 12, 20, 24, 25, 14, 16};
    
    sorted = new int[arr.length];
    
    mergeSort(arr, 0, arr.length - 1);
}
```





### 병합정렬 알고리즘의 특징

#### 장점

$O(nlog(n))$을 최악의 경우에도 보장한다.
즉, 입력 데이터가 무엇이건 간에 정렬 시간은 동일하다. 이를 안정적인 정렬 방법이라 한다.
레코드를 연결 리스트로 구성하면, 링크 인덱스만 변경하면 되므로 제자리 정렬이 가능해지고, 이는 데이터의 이동을 무시할 수 있을 정도로 작게 처리할 수 있게 된다. 



#### 단점

하지만, 공간복잡도에서 메모리가 정렬대상의 배열만큼 필요하다는 단점이 있다. 다른말로는 제자리 정렬(in-place sorting)이 아니다라고도 한다.
즉, 데이터 크기가 큰 경우에는 임시 배열의 크기가 커지면 이동 횟수가 많아지므로 매우 큰 시간적 낭비를 초래할 수 있다.



### 참고

- <https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html>
- <https://www.youtube.com/watch?v=ctkuGoJPmAE&list=PLRx0vPvlEmdDHxCvAQS1_6XV4deOwfVrz&index=8>